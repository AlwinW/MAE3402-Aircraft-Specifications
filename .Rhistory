LabelledBatteryFractioncontourplot
Swingcontourplot <- ggplot(data = weightoptim, aes(x = WS, y = PW)) +
stat_contour(aes(z = S_wing, colour = ..level..)
) +
ggtitle("Wing Area")
direct.label(Swingcontourplot, method = "top.pieces")
# Wing area (iterated solution)
# Decreases with increasing WS (duh) but more curvature at higher WS
Swingcontourplot <- ggplot(data = weightoptim, aes(x = WS, y = PW)) +
stat_contour(aes(z = S_wing, colour = ..level..),
breaks = c(seq(5,24, 1), seq(25,100,5))
) +
ggtitle("Wing Area")
direct.label(Swingcontourplot, method = "top.pieces")
Cd0contourplot <- ggplot(data = weightoptim, aes(x = WS, y = PW)) +
stat_contour(aes(z = Cd0, colour = ..level..)
)
direct.label(Cd0contourplot, method = "top.pieces")
direct.label(Swingcontourplot, method = "top.pieces")
Swingcontourplot <- ggplot(data = weightoptim, aes(x = WS, y = PW)) +
stat_contour(aes(z = S_wing, colour = ..level..),
breaks = c(seq(5,20, 1), seq(21, 30, 3), seq(25,100,5))
) +
ggtitle("Wing Area")
direct.label(Swingcontourplot, method = "top.pieces")
Swingcontourplot <- ggplot(data = weightoptim, aes(x = WS, y = PW)) +
stat_contour(aes(z = S_wing, colour = ..level..),
breaks = c(seq(5,20, 1), seq(24, 30, 3), seq(25,100,5))) +
geom_point(data = inp, aes(x = WS, y = P0/W, label = "Design")) +
ggtitle("Wing Area")
direct.label(Swingcontourplot, method = "top.pieces")
Swingcontourplot <- ggplot(data = weightoptim, aes(x = WS, y = PW)) +
stat_contour(aes(z = S_wing, colour = ..level..),
breaks = c(seq(5,23, 1), seq(24, 30, 3), seq(25,100,5))) +
geom_point(data = inp, aes(x = WS, y = P0/W, label = "Design")) +
ggtitle("Wing Area")
direct.label(Swingcontourplot, method = "top.pieces")
# Wing area (iterated solution)
# Decreases with increasing WS (duh) but more curvature at higher WS
Swingcontourplot <- ggplot(data = weightoptim, aes(x = WS, y = PW)) +
stat_contour(aes(z = S_wing, colour = ..level..),
breaks = c(seq(5,23, 1), seq(24, 30, 2), seq(25,100,5))) +
geom_point(data = inp, aes(x = WS, y = P0/W, label = "Design")) +
ggtitle("Wing Area")
direct.label(Swingcontourplot, method = "top.pieces")
# Wing area (iterated solution)
# Decreases with increasing WS (duh) but more curvature at higher WS
Swingcontourplot <- ggplot(data = weightoptim, aes(x = WS, y = PW)) +
stat_contour(aes(z = S_wing, colour = ..level..),
breaks = c(seq(5,23, 1), seq(24, 30, 2.5), seq(25,100,5))) +
geom_point(data = inp, aes(x = WS, y = P0/W, label = "Design")) +
ggtitle("Wing Area")
direct.label(Swingcontourplot, method = "top.pieces")
Swingcontourplot <- ggplot(data = weightoptim, aes(x = WS, y = PW)) +
stat_contour(aes(z = S_wing, colour = ..level..),
breaks = c(seq(5,23, 1), seq(25, 30, 2.5), seq(25,100,5))) +
geom_point(data = inp, aes(x = WS, y = P0/W, label = "Design")) +
ggtitle("Wing Area")
direct.label(Swingcontourplot, method = "top.pieces")
Savingplot <- ggplot(data = weightoptim, aes(x = WS, y = PW)) +
stat_contour(aes(z = Saving_Total, colour = ..level..)
)
direct.label(Savingplot, method = "top.pieces")
Savingplot <- ggplot(data = weightoptim, aes(x = WS, y = PW))+
stat_contour(aes(z = Saving_Total, colour = ..level..),
breaks = c(seq(100, 150, 10), seq(150, 200, 25), seq(200, 1000, 50))
)
direct.label(Savingplot, method = "top.pieces")
Savingplot <- ggplot(data = weightoptim, aes(x = WS, y = PW))+
stat_contour(aes(z = Saving_Total, colour = ..level..),
breaks = c(seq(100, 150, 5), seq(150, 200, 25), seq(200, 1000, 50))
)
direct.label(Savingplot, method = "top.pieces")
Savingplot <- ggplot(data = weightoptim, aes(x = WS, y = PW))+
stat_contour(aes(z = Saving_Total, colour = ..level..),
breaks = c(seq(100, 150, 10), seq(150, 200, 25), seq(200, 1000, 50))
)
direct.label(Savingplot, method = "top.pieces")
Savingplot <- ggplot(data = weightoptim, aes(x = WS, y = PW))+
stat_contour(aes(z = Saving_Total, colour = ..level..),
breaks = c(seq(100, 150, 10), seq(150, 200, 25), seq(200, 1000, 50))
) +
geom_point(data = inp, aes(x = WS, y = P0/W, label = "Design")) +
ggtitle("Composite Weight Saving (Raymer Correlation)")
direct.label(Savingplot, method = "top.pieces")
weightoptimdiscrete <- weightoptim
brks <- cut(weightoptim$MTOM, breaks = seq(3000, 20000, 500), dig.lab = 10)
brks <- gsub(",", " - ", brks, fixed = TRUE)
weightoptimdiscrete$MTOM <- gsub("\\(|\\]","",brks)
ggplot(data = weightoptimdiscrete, aes(x = WS, y = PW)) +
geom_tile(aes(fill = MTOM))
source('C:/Users/Alwin/Documents/GitHub/MAE3402-Aircraft-Specifications/Helper Install Packages.R', echo=TRUE)
weightoptimdiscrete <- weightoptim
brks <- cut(weightoptim$MTOM, breaks = seq(3000, 20000, 500), dig.lab = 10)
brks <- gsub(",", " - ", brks, fixed = TRUE)
weightoptimdiscrete$MTOM <- gsub("\\(|\\]","",brks)
ggplot(data = weightoptimdiscrete, aes(x = WS, y = PW)) +
geom_tile(aes(fill = MTOM))
weightoptimdiscrete$MTOM
library(lattice)
head(weightoptim)
source('C:/Users/Alwin/Documents/GitHub/MAE3402-Aircraft-Specifications/Helper Constraint Analysis.R', echo=TRUE)
ConstraintPlot
AR = 20
# Grid of data values
varWS <- seq(1500,3500, length.out = 51)
varPW <- seq(0, 30, length.out = 51)
weightoptim <- expand.grid(WS = varWS, PW = varPW)
weightoptim <- weightoptim %>%
rowwise() %>%
do(data.frame(
# Previous WS and PW values
.,
# Determine MTOM
MTOM = ModifiedSecant(
function(W_dg_SI)
W_dg_SI - Weight_Estimate(.$WS, .$PW, W_dg_SI, composite = TRUE, iteration = TRUE),
6000, 0.001,0.01, positive = TRUE
)
)) %>%
do(data.frame(
.,
Weight_Estimate(.$WS, .$PW, .$MTOM, composite = TRUE, iteration = FALSE)[[1]]
))
weightoptim <- data.frame(weightoptim)
# Discrete Filled Contours
weightoptimdiscrete <- weightoptim
brks <- cut(weightoptim$MTOM, breaks = seq(3000, 20000, 500), dig.lab = 10)
brks <- gsub(",", " - ", brks, fixed = TRUE)
weightoptimdiscrete$MTOM <- gsub("\\(|\\]","",brks)
ggplot(data = weightoptimdiscrete, aes(x = WS, y = PW)) +
geom_tile(aes(fill = MTOM))
weightoptimdiscrete <- weightoptim
brks <- cut(weightoptim$MTOM, breaks = seq(3000, 20000, 500), dig.lab = 10)
brks <- gsub(",", " - ", brks, fixed = TRUE)
weightoptimdiscrete$MTOM <- gsub("\\(|\\]","",brks)
ggplot(data = weightoptimdiscrete, aes(x = WS, y = PW)) +
geom_tile(aes(fill = MTOM))
#define data
x<-seq(1,11,1)
y<-seq(1,11,1)
xyz.func<-function(x,y) {-10.4+6.53*x+6.53*y-0.167*x^2-0.167*y^2+0.0500*x*y}
#contour plot using lattice graphics and R Color Brewer
library(lattice) #for filled.contour()
library(RColorBrewer) #for brewer.pal()
z.lattice<-outer(x,y,xyz.func)
filled.contour(x,y,z.lattice,nlevels=6,col=brewer.pal(6,"YlOrRd"))
z
z.lattice
MTOMlattice <- weightoptim %>%
select(WS, PW, MTOM)
MTOMlattice
?spread
MTOMlattice <- weightoptim %>%
select(WS, PW, MTOM) %>%
spread(WS, MTOM)
MTOMlattice
MTOMlattice <- weightoptim %>%
select(WS, PW, MTOM) %>%
spread(WS, MTOM)
rownames(MTOMlattice) <- MTOMlattice$PW
MTOMlattice <- select(-PW)
MTOMlattice <- weightoptim %>%
select(WS, PW, MTOM) %>%
spread(WS, MTOM)
rownames(MTOMlattice) <- MTOMlattice$PW
MTOMlattice <- select(MTOMlattice, -PW)
MTOMlattice
view(MTOMlattice)
Ciew(MTOMlattice)
View(MTOMlattice)
filled.contour(varWS,varPW,MTOMlattice,nlevels=6,col=brewer.pal(6,"YlOrRd"))
varWS
varPW
class(z.lattice)
asdf  <- matrix(MTOMlattice)
filled.contour(varWS,varPW,asdf,nlevels=6,col=brewer.pal(6,"YlOrRd"))
AR = 20
# Grid of data values
varWS <- seq(1500,3500, length.out = 11)
varPW <- seq(0, 30, length.out = 11)
weightoptim <- expand.grid(WS = varWS, PW = varPW)
weightoptim <- weightoptim %>%
rowwise() %>%
do(data.frame(
# Previous WS and PW values
.,
# Determine MTOM
MTOM = ModifiedSecant(
function(W_dg_SI)
W_dg_SI - Weight_Estimate(.$WS, .$PW, W_dg_SI, composite = TRUE, iteration = TRUE),
6000, 0.001,0.01, positive = TRUE
)
)) %>%
do(data.frame(
.,
Weight_Estimate(.$WS, .$PW, .$MTOM, composite = TRUE, iteration = FALSE)[[1]]
))
weightoptim <- data.frame(weightoptim)
MTOMlattice <- weightoptim %>%
select(WS, PW, MTOM) %>%
spread(WS, MTOM)
rownames(MTOMlattice) <- MTOMlattice$PW
MTOMlattice <- select(MTOMlattice, -PW)
asdf <- matrix(MTOMlattice)
filled.contour(varWS,varPW,asdf,nlevels=6,col=brewer.pal(6,"YlOrRd"))
asdf
MTOMlattice
asdf <- as.matrix(MTOMlattice)
asdf
filled.contour(varWS,varPW,asdf,nlevels=6,col=brewer.pal(6,"YlOrRd"))
MTOMlattice <- weightoptim %>%
select(WS, PW, MTOM) %>%
spread(PW, MTOM)
rownames(MTOMlattice) <- MTOMlattice$WS
MTOMlattice <- select(MTOMlattice, -WS)
MTOMlattice <- weightoptim %>%
select(WS, PW, MTOM) %>%
spread(PW, MTOM)
rownames(MTOMlattice) <- MTOMlattice$WS
MTOMlattice <- select(MTOMlattice, -WS)
asdf <- as.matrix(MTOMlattice)
filled.contour(varWS,varPW,asdf,nlevels=6,col=brewer.pal(6,"YlOrRd"))
MTOMlattice <- weightoptim %>%
select(WS, PW, MTOM) %>%
spread(PW, MTOM)
rownames(MTOMlattice) <- MTOMlattice$WS
MTOMlattice <- select(MTOMlattice, -WS)
asdf <- as.matrix(MTOMlattice)
filled.contour(varWS,varPW,asdf,nlevels=8,col=brewer.pal(8,"YlOrRd"))
?filled.contour
MTOMlattice <- weightoptim %>%
select(WS, PW, MTOM) %>%
spread(PW, MTOM)
rownames(MTOMlattice) <- MTOMlattice$WS
MTOMlattice <- select(MTOMlattice, -WS)
asdf <- as.matrix(MTOMlattice)
filled.contour(varWS,varPW,asdf,nlevels=11,col=brewer.pal(11,"YlOrRd"))
MTOMlattice <- weightoptim %>%
select(WS, PW, MTOM) %>%
spread(PW, MTOM)
rownames(MTOMlattice) <- MTOMlattice$WS
MTOMlattice <- select(MTOMlattice, -WS)
asdf <- as.matrix(MTOMlattice)
filled.contour(varWS,varPW,asdf,nlevels=10,col=brewer.pal(10,"YlOrRd"))
MTOMlattice <- weightoptim %>%
select(WS, PW, MTOM) %>%
spread(PW, MTOM)
rownames(MTOMlattice) <- MTOMlattice$WS
MTOMlattice <- select(MTOMlattice, -WS)
asdf <- as.matrix(MTOMlattice)
filled.contour(varWS,varPW,asdf,nlevels=9,col=brewer.pal(9,"YlOrRd"))
AR = 20
# Grid of data values
varWS <- seq(2000,3500, length.out = 11)
varPW <- seq(0, 30, length.out = 11)
weightoptim <- expand.grid(WS = varWS, PW = varPW)
weightoptim <- weightoptim %>%
rowwise() %>%
do(data.frame(
# Previous WS and PW values
.,
# Determine MTOM
MTOM = ModifiedSecant(
function(W_dg_SI)
W_dg_SI - Weight_Estimate(.$WS, .$PW, W_dg_SI, composite = TRUE, iteration = TRUE),
6000, 0.001,0.01, positive = TRUE
)
)) %>%
do(data.frame(
.,
Weight_Estimate(.$WS, .$PW, .$MTOM, composite = TRUE, iteration = FALSE)[[1]]
))
weightoptim <- data.frame(weightoptim)
# Discrete Filled Contours
weightoptimdiscrete <- weightoptim
brks <- cut(weightoptim$MTOM, breaks = seq(3000, 20000, 500), dig.lab = 10)
brks <- gsub(",", " - ", brks, fixed = TRUE)
weightoptimdiscrete$MTOM <- gsub("\\(|\\]","",brks)
ggplot(data = weightoptimdiscrete, aes(x = WS, y = PW)) +
geom_tile(aes(fill = MTOM))
# +
#   scale_fill_manual("MTOM",values=brewer.pal(14,"YlOrRd"))
MTOMlattice <- weightoptim %>%
select(WS, PW, MTOM) %>%
spread(PW, MTOM)
rownames(MTOMlattice) <- MTOMlattice$WS
MTOMlattice <- select(MTOMlattice, -WS)
asdf <- as.matrix(MTOMlattice)
filled.contour(varWS,varPW,asdf,nlevels=9,col=brewer.pal(9,"YlOrRd"))
source('C:/Users/Alwin/Documents/GitHub/MAE3402-Aircraft-Specifications/Helper Install Packages.R', echo=TRUE)
?stat_contour
ggplot(data = weightoptim, aes(x = WS, y = PW)) +
stat_contour(aes(z = MTOM, colour = ..level..), #breaks=c(c(seq(4000, 8000, 100), seq(7000, 20000, 500)))
geom = "polygon") +
geom_point(data = inp, aes(x = WS, y = P0/W, label = "Design")) +
ggtitle("MTOM")
ggplot(data = weightoptim, aes(x = WS, y = PW)) +
geom_raster(aes(fill = MTOM)) +
geom_point(data = inp, aes(x = WS, y = P0/W, label = "Design")) +
ggtitle("MTOM")
gplot(data = weightoptim, aes(x = WS, y = PW)) +
geom_raster(aes(fill = MTOM)) +
stat_contour(aes(z = MTOM), colour = "white") +
geom_point(data = inp, aes(x = WS, y = P0/W, label = "Design")) +
ggtitle("MTOM")
ggplot(data = weightoptim, aes(x = WS, y = PW)) +
geom_raster(aes(fill = MTOM)) +
stat_contour(aes(z = MTOM), colour = "white") +
geom_point(data = inp, aes(x = WS, y = P0/W, label = "Design")) +
ggtitle("MTOM")
direct.label(
ggplot(data = weightoptim, aes(x = WS, y = PW)) +
geom_raster(aes(fill = MTOM)) +
stat_contour(aes(z = MTOM), colour = "white") +
geom_point(data = inp, aes(x = WS, y = P0/W, label = "Design")) +
ggtitle("MTOM"),
method = "top.pieces")
direct.label(
ggplot(data = weightoptim, aes(x = WS, y = PW)) +
# geom_raster(aes(fill = MTOM)) +
stat_contour(aes(z = MTOM), colour = "white") +
geom_point(data = inp, aes(x = WS, y = P0/W, label = "Design")) +
ggtitle("MTOM"),
method = "top.pieces")
direct.label(
ggplot(data = weightoptim, aes(x = WS, y = PW)) +
# geom_raster(aes(fill = MTOM)) +
stat_contour(aes(z = MTOM, colour = ..level..)) +
geom_point(data = inp, aes(x = WS, y = P0/W, label = "Design")) +
ggtitle("MTOM"),
method = "top.pieces")
direct.label(
ggplot(data = weightoptim, aes(x = WS, y = PW)) +
geom_raster(aes(fill = MTOM)) +
stat_contour(aes(z = MTOM, colour = ..level..)) +
geom_point(data = inp, aes(x = WS, y = P0/W, label = "Design")) +
ggtitle("MTOM"),
method = "top.pieces")
source('C:/Users/Alwin/Documents/GitHub/MAE3402-Aircraft-Specifications/Helper Install Packages.R', echo=TRUE)
inp
66684.2 / 2721.804
66684.2 / 9.81
6900 * 9.8065
67664.85 / 24.5
source('C:/Users/Alwin/Documents/GitHub/MAE3402-Aircraft-Specifications/Helper Initial Values.R', echo=TRUE)
source('C:/Users/Alwin/Documents/GitHub/MAE3402-Aircraft-Specifications/Helper Initial Values.R', echo=TRUE)
out <- StandardAtomsphere(out) %>%
mutate(Vinf = Mach * a,
Vstall = Vmin(rho, WS, Clmax))
out$Vinf <- c(out$Vinf[1], out$Vinf[2], out$Vinf[3], out$Vstall[4] * 1.2, out$Vstall[5] * 1.3)
out <- out %>%
mutate(Vsafe = 1.2 * Vstall,
qinf = 1/2 * rho * Vinf^2,
Cl = W / (qinf * S),
Cd = Cd0 + K * Cl^2,
ClCd = Cl/Cd,
Clstar = sqrt(Cd0 / K),
Cdstar = 2 * Cd0,
ClCdstar = 1 / sqrt(4 * Cd0 * K),
Vstar = Vmin(rho, WS, Clstar),
Cl32 = sqrt(3) * Clstar,
Cd32 = 2 * Cdstar,
ClCd32 = sqrt(3/4) * ClCdstar,
V32 = (1/3)^(1/4) * Vstar
)
#--- Create a meaningful output to be returned  to a user
AeroParamsTable <- select(
out,
type, h, rho, Vinf, Vstall, Vsafe, Vstar, V32,
Cl, Clstar, Cl32, Clmax, Cd, Cdstar, Cd32,
ClCd, ClCdstar, ClCd32)
inp
InpSpecs(input_initial, specifications)
out <-  inp[rep(row.names(inp), each = 5), 1:length(inp)]
out$type <- c("Sea Level", "Cruise", "Ceiling", "Takeoff", "Landing")
out$h <- c(0, inp$AltCruise, inp$AltCeil, 0, 0)
out$Clmax <- inp$Clclean + c(0, 0, 0, inp$Clflaps, inp$Clhls)
# Transform the dataframe to find the various aerodynamic properties
out <- StandardAtomsphere(out) %>%
mutate(Vinf = Mach * a,
Vstall = Vmin(rho, WS, Clmax))
out$Vinf <- c(out$Vinf[1], out$Vinf[2], out$Vinf[3], out$Vstall[4] * 1.2, out$Vstall[5] * 1.3)
out <- out %>%
mutate(Vsafe = 1.2 * Vstall,
qinf = 1/2 * rho * Vinf^2,
Cl = W / (qinf * S),
Cd = Cd0 + K * Cl^2,
ClCd = Cl/Cd,
Clstar = sqrt(Cd0 / K),
Cdstar = 2 * Cd0,
ClCdstar = 1 / sqrt(4 * Cd0 * K),
Vstar = Vmin(rho, WS, Clstar),
Cl32 = sqrt(3) * Clstar,
Cd32 = 2 * Cdstar,
ClCd32 = sqrt(3/4) * ClCdstar,
V32 = (1/3)^(1/4) * Vstar
)
#--- Create a meaningful output to be returned  to a user
AeroParamsTable <- select(
out,
type, h, rho, Vinf, Vstall, Vsafe, Vstar, V32,
Cl, Clstar, Cl32, Clmax, Cd, Cdstar, Cd32,
ClCd, ClCdstar, ClCd32)
AeroParamsTable
AeroParamsTable
6900 * 9.8065 / (1/2*0.9046291*82.09822^2)
6900 * 9.8065 / (1/2*0.9046291*82.09822^2*24.5)
out
6900*9.81
6900*9.8065
inp  <- InpSpecs(input_initial, specifications)
out <-  inp[rep(row.names(inp), each = 5), 1:length(inp)]
out$type <- c("Sea Level", "Cruise", "Ceiling", "Takeoff", "Landing")
out$h <- c(0, inp$AltCruise, inp$AltCeil, 0, 0)
out$Clmax <- inp$Clclean + c(0, 0, 0, inp$Clflaps, inp$Clhls)
# Transform the dataframe to find the various aerodynamic properties
out <- StandardAtomsphere(out) %>%
mutate(Vinf = Mach * a,
Vstall = Vmin(rho, WS, Clmax))
out$Vinf <- c(out$Vinf[1], out$Vinf[2], out$Vinf[3], out$Vstall[4] * 1.2, out$Vstall[5] * 1.3)
out <- out %>%
mutate(Vsafe = 1.2 * Vstall,
qinf = 1/2 * rho * Vinf^2,
Cl = W / (qinf * S),
Cd = Cd0 + K * Cl^2,
ClCd = Cl/Cd,
Clstar = sqrt(Cd0 / K),
Cdstar = 2 * Cd0,
ClCdstar = 1 / sqrt(4 * Cd0 * K),
Vstar = Vmin(rho, WS, Clstar),
Cl32 = sqrt(3) * Clstar,
Cd32 = 2 * Cdstar,
ClCd32 = sqrt(3/4) * ClCdstar,
V32 = (1/3)^(1/4) * Vstar
)
#--- Create a meaningful output to be returned  to a user
AeroParamsTable <- select(
out,
type, h, rho, Vinf, Vstall, Vsafe, Vstar, V32,
Cl, Clstar, Cl32, Clmax, Cd, Cdstar, Cd32,
ClCd, ClCdstar, ClCd32)
out <-  inp[rep(row.names(inp), each = 5), 1:length(inp)]
out$type <- c("Sea Level", "Cruise", "Ceiling", "Takeoff", "Landing")
out$h <- c(0, inp$AltCruise, inp$AltCeil, 0, 0)
inp$Clclean
c(0, 0, 0, inp$Clflaps, inp$Clhls)
inp$Clclean + c(0, 0, 0, inp$Clflaps, inp$Clhls)
out$Clmax
out$h
out$Clmax <- inp$Clclean + c(0, 0, 0, inp$Clflaps, inp$Clhls)
out <- StandardAtomsphere(out) %>%
mutate(Vinf = Mach * a,
Vstall = Vmin(rho, WS, Clmax))
out$Vinf <- c(out$Vinf[1], out$Vinf[2], out$Vinf[3], out$Vstall[4] * 1.2, out$Vstall[5] * 1.3)
out <- out %>%
mutate(Vsafe = 1.2 * Vstall,
qinf = 1/2 * rho * Vinf^2,
Cl = W / (qinf * S),
Cd = Cd0 + K * Cl^2,
ClCd = Cl/Cd,
Clstar = sqrt(Cd0 / K),
Cdstar = 2 * Cd0,
ClCdstar = 1 / sqrt(4 * Cd0 * K),
Vstar = Vmin(rho, WS, Clstar),
Cl32 = sqrt(3) * Clstar,
Cd32 = 2 * Cdstar,
ClCd32 = sqrt(3/4) * ClCdstar,
V32 = (1/3)^(1/4) * Vstar
)
rm(out)
inp
inp <- InpSpecs(input_initial, specifications)
inp
inp <- InpSpecs(input_initial, specifications_description)
inp
out <-  inp[rep(row.names(inp), each = 5), 1:length(inp)]
out$type <- c("Sea Level", "Cruise", "Ceiling", "Takeoff", "Landing")
out$h <- c(0, inp$AltCruise, inp$AltCeil, 0, 0)
out$Clmax <- inp$Clclean + c(0, 0, 0, inp$Clflaps, inp$Clhls)
# Transform the dataframe to find the various aerodynamic properties
out <- StandardAtomsphere(out) %>%
mutate(Vinf = Mach * a,
Vstall = Vmin(rho, WS, Clmax))
out$Vinf <- c(out$Vinf[1], out$Vinf[2], out$Vinf[3], out$Vstall[4] * 1.2, out$Vstall[5] * 1.3)
out <- out %>%
mutate(Vsafe = 1.2 * Vstall,
qinf = 1/2 * rho * Vinf^2,
Cl = W / (qinf * S),
Cd = Cd0 + K * Cl^2,
ClCd = Cl/Cd,
Clstar = sqrt(Cd0 / K),
Cdstar = 2 * Cd0,
ClCdstar = 1 / sqrt(4 * Cd0 * K),
Vstar = Vmin(rho, WS, Clstar),
Cl32 = sqrt(3) * Clstar,
Cd32 = 2 * Cdstar,
ClCd32 = sqrt(3/4) * ClCdstar,
V32 = (1/3)^(1/4) * Vstar
)
#--- Create a meaningful output to be returned  to a user
AeroParamsTable <- select(
out,
type, h, rho, Vinf, Vstall, Vsafe, Vstar, V32,
Cl, Clstar, Cl32, Clmax, Cd, Cdstar, Cd32,
ClCd, ClCdstar, ClCd32)
AeroParamsTable
out
mutate(D = qinf * Cd * S)
mutate(out, D = qinf * Cd * S)
mutate(out, D = qinf * Cd * S, PR = D * V)
mutate(out, D = qinf * Cd * S, PR = D * Vinf)
