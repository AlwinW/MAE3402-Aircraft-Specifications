D = qinf * S * Cd,
L = qinf * S * ClTR) %>%
rowwise() %>%
mutate(
R = (VTR) ^ 2 / (0.2 * g),
gamma = ClimbRatesFunction(PA, Cd0, rho, VTR, S, K, W)[[1]] * pi / 180,
hTR = R * (1 - cos(gamma)),
ST = R * (sin(gamma)),
SC = (Hobs - hTR) / tan(gamma),
Sair = ifelse(SC >0, ST + SC, sqrt(R^2 - (R-hTR)^2))
)%>%
ungroup()
AirDistanceTO <- data.frame(select(AirDistanceTO, type, R, gamma, hTR, ST, SC, Sair))
#--- Calculate the other TO parameters and find V1
TO <- TO %>%
mutate(
# Cl = Cl0,
K = Keff(K, hground, b),
Cd = Cd0 + K * Cl^2
)
#--- Test if the graphs will cross over before V2
BFL <- try(ModifiedSecant(function(V1) AccelerateContinue(TO, AirDistanceTO, V1, V2) - AccelerateStop(TO, V1),
V2, 0.01, 1e-4, positive = TRUE), silent = TRUE)
if (is.numeric(BFL)){
V1 = ModifiedSecant(function(V1) AccelerateContinue(TO, AirDistanceTO, V1, V2) - AccelerateStop(TO, V1),
V2, 0.01, 1e-4, positive = TRUE)
BFL = AccelerateContinue(TO, AirDistanceTO, V1, V2)
} else {
V1 = NA
BFL = 0
}
#--- Output the results
TOoutput <- data.frame(
V1 = V1,
V2 = V2,
BFL = BFL,
NTO = AccelerateLiftOff(TO, AirDistanceTO, V2)
) %>%
mutate(
NTOgr = NTO - AirDistanceTO$Sair[1],
TakeOffLength = max(BFL*as.numeric(V1 <= V2), NTO)
)
rm(AirDistance)
#--- Set up the initial parameters to solve for
TO <- RepeatRows(inp, 3)
TO$segment <- "Takeoff"
TO$type <- c("All Engines", "One Engine Down", "Rejected Take-Off")
TO$Ne <- c(2, 1, 0)
TO$mu <- c(
as.double(groundmu["Dry Concrete", "brakesoff"]),
as.double(groundmu["Dry Concrete", "brakesoff"]),
as.double(groundmu["Dry Concrete", "brakeson"])
)
#---- Determine aerodynamic parameters
TO <- mutate(TO, h = 0) %>%
StandardAtomsphere(.) %>%
mutate(
Cd0 = Cd0clean + Cd0lg + Cd0flaps + Cdiflaps,
Cd0 = Cd0 + as.numeric(Ne == 1) * Cd0propfea + as.numeric(Ne == 0) * 2 * Cd0propunfea,
Cl = Cl0 + Clflaps
)
#--- Determine the AirDistance in each case
AirDistanceTO <- TO %>%
filter(type %in% c("All Engines", "One Engine Down")) %>%
mutate(ClTR = Clclean + Clflaps,
VTR = VsTO * 1.15,
etaprop = etaprop(VTR),
PA = PA(Pshafteng, Ne, VTR),
TA = PA / VTR,
qinf = 1/2 * rho * VTR^2,
Cd = Cd0 + K * ClTR^2,
D = qinf * S * Cd,
L = qinf * S * ClTR) %>%
rowwise() %>%
mutate(
R = (VTR) ^ 2 / (0.2 * g),
gamma = ClimbRatesFunction(PA, Cd0, rho, VTR, S, K, W)[[1]] * pi / 180,
hTR = R * (1 - cos(gamma)),
ST = R * (sin(gamma)),
SC = (Hobs - hTR) / tan(gamma),
Sair = ifelse(SC >0, ST + SC, sqrt(R^2 - (R-hTR)^2))
)%>%
ungroup()
AirDistanceTO <- data.frame(select(AirDistanceTO, type, R, gamma, hTR, ST, SC, Sair))
#--- Calculate the other TO parameters and find V1
TO <- TO %>%
mutate(
# Cl = Cl0,
K = Keff(K, hground, b),
Cd = Cd0 + K * Cl^2
)
#--- Test if the graphs will cross over before V2
BFL <- try(ModifiedSecant(function(V1) AccelerateContinue(TO, AirDistanceTO, V1, V2) - AccelerateStop(TO, V1),
V2, 0.01, 1e-4, positive = TRUE), silent = TRUE)
if (is.numeric(BFL)){
V1 = ModifiedSecant(function(V1) AccelerateContinue(TO, AirDistanceTO, V1, V2) - AccelerateStop(TO, V1),
V2, 0.01, 1e-4, positive = TRUE)
BFL = AccelerateContinue(TO, AirDistanceTO, V1, V2)
} else {
V1 = NA
BFL = 0
}
#--- Output the results
TOoutput <- data.frame(
V1 = V1,
V2 = V2,
BFL = BFL,
NTO = AccelerateLiftOff(TO, AirDistanceTO, V2)
) %>%
mutate(
NTOgr = NTO - AirDistanceTO$Sair[1],
TakeOffLength = max(BFL*as.numeric(V1 <= V2), NTO)
)
TOoutput
TO <- TO %>%
mutate(
Cl = Cl0,
K = Keff(K, hground, b),
Cd = Cd0 + K * Cl^2
)
#--- Test if the graphs will cross over before V2
BFL <- try(ModifiedSecant(function(V1) AccelerateContinue(TO, AirDistanceTO, V1, V2) - AccelerateStop(TO, V1),
V2, 0.01, 1e-4, positive = TRUE), silent = TRUE)
if (is.numeric(BFL)){
V1 = ModifiedSecant(function(V1) AccelerateContinue(TO, AirDistanceTO, V1, V2) - AccelerateStop(TO, V1),
V2, 0.01, 1e-4, positive = TRUE)
BFL = AccelerateContinue(TO, AirDistanceTO, V1, V2)
} else {
V1 = NA
BFL = 0
}
#--- Output the results
TOoutput <- data.frame(
V1 = V1,
V2 = V2,
BFL = BFL,
NTO = AccelerateLiftOff(TO, AirDistanceTO, V2)
) %>%
mutate(
NTOgr = NTO - AirDistanceTO$Sair[1],
TakeOffLength = max(BFL*as.numeric(V1 <= V2), NTO)
)
TO <- TO %>%
mutate(
Cl = Cl0,
K = Keff(K, hground, b),
Cd = Cd0 + K * Cl^2
)
#--- Test if the graphs will cross over before V2
BFL <- try(ModifiedSecant(function(V1) AccelerateContinue(TO, AirDistanceTO, V1, V2) - AccelerateStop(TO, V1),
V2, 0.01, 1e-4, positive = TRUE), silent = TRUE)
if (is.numeric(BFL)){
V1 = ModifiedSecant(function(V1) AccelerateContinue(TO, AirDistanceTO, V1, V2) - AccelerateStop(TO, V1),
V2, 0.01, 1e-4, positive = TRUE)
BFL = AccelerateContinue(TO, AirDistanceTO, V1, V2)
} else {
V1 = NA
BFL = 0
}
#--- Output the results
TOoutput <- data.frame(
V1 = V1,
V2 = V2,
BFL = BFL,
NTO = AccelerateLiftOff(TO, AirDistanceTO, V2)
) %>%
mutate(
NTOgr = NTO - AirDistanceTO$Sair[1],
TakeOffLength = max(BFL*as.numeric(V1 <= V2), NTO)
)
TOoutput
inp$Cl0
#--- Set up the initial parameters to solve for
TO <- RepeatRows(inp, 3)
TO$segment <- "Takeoff"
TO$type <- c("All Engines", "One Engine Down", "Rejected Take-Off")
TO$Ne <- c(2, 1, 0)
TO$mu <- c(
as.double(groundmu["Dry Concrete", "brakesoff"]),
as.double(groundmu["Dry Concrete", "brakesoff"]),
as.double(groundmu["Dry Concrete", "brakeson"])
)
#---- Determine aerodynamic parameters
TO <- mutate(TO, h = 0) %>%
StandardAtomsphere(.) %>%
mutate(
Cd0 = Cd0clean + Cd0lg + Cd0flaps + Cdiflaps,
Cd0 = Cd0 + as.numeric(Ne == 1) * Cd0propfea + as.numeric(Ne == 0) * 2 * Cd0propunfea,
Cl = Cl0 + Clflaps
)
#--- Determine the AirDistance in each case
AirDistanceTO <- TO %>%
filter(type %in% c("All Engines", "One Engine Down")) %>%
mutate(ClTR = Clclean + Clflaps,
VTR = VsTO * 1.15,
etaprop = etaprop(VTR),
PA = PA(Pshafteng, Ne, VTR),
TA = PA / VTR,
qinf = 1/2 * rho * VTR^2,
Cd = Cd0 + K * ClTR^2,
D = qinf * S * Cd,
L = qinf * S * ClTR) %>%
rowwise() %>%
mutate(
R = (VTR) ^ 2 / (0.2 * g),
gamma = ClimbRatesFunction(PA, Cd0, rho, VTR, S, K, W)[[1]] * pi / 180,
hTR = R * (1 - cos(gamma)),
ST = R * (sin(gamma)),
SC = (Hobs - hTR) / tan(gamma),
Sair = ifelse(SC >0, ST + SC, sqrt(R^2 - (R-hTR)^2))
)%>%
ungroup()
AirDistanceTO <- data.frame(select(AirDistanceTO, type, R, gamma, hTR, ST, SC, Sair))
#--- Calculate the other TO parameters and find V1
TO <- TO %>%
mutate(
K = Keff(K, hground, b),
Cd = Cd0 + K * Cl^2
)
#--- Test if the graphs will cross over before V2
BFL <- try(ModifiedSecant(function(V1) AccelerateContinue(TO, AirDistanceTO, V1, V2) - AccelerateStop(TO, V1),
V2, 0.01, 1e-4, positive = TRUE), silent = TRUE)
if (is.numeric(BFL)){
V1 = ModifiedSecant(function(V1) AccelerateContinue(TO, AirDistanceTO, V1, V2) - AccelerateStop(TO, V1),
V2, 0.01, 1e-4, positive = TRUE)
BFL = AccelerateContinue(TO, AirDistanceTO, V1, V2)
} else {
V1 = NA
BFL = 0
}
#--- Output the results
TOoutput <- data.frame(
V1 = V1,
V2 = V2,
BFL = BFL,
NTO = AccelerateLiftOff(TO, AirDistanceTO, V2)
) %>%
mutate(
NTOgr = NTO - AirDistanceTO$Sair[1],
TakeOffLength = max(BFL*as.numeric(V1 <= V2), NTO)
)
V/GroundAcceleration(LD, 50, distancecalc = TRUE)
#---- Determine aerodynamic parameters
LD <- mutate(LD, h = 0) %>%
StandardAtomsphere(.) %>%
mutate(
K = Keff(K, hground, b),
Cd0 = Cd0clean + Cd0lg + Cd0flaps + Cdiflaps,
Cd0 = Cd0 + as.numeric(Ne == 1) * Cd0propfea + as.numeric(Ne == 0) * 2 * Cd0propunfea,
Cl = Cl0 + Clflaps,
Cd = Cd0 + KK * Cl^2
)
#--- Calculate the other LD parameters and find V1
LD <- LD %>%
mutate(
K = Keff(K, hground, b),
Cd = Cd0 + K * Cl^2
)
#--- Set up the initial parameters to solve for
LD <- inp
LD$segment <- "Landing"
LD$type <- "Landing"
LD$Ne <-0
LD$mu <- c(
as.double(groundmu["Dry Concrete", "brakeson"])
)
#---- Determine aerodynamic parameters
LD <- mutate(LD, h = 0) %>%
StandardAtomsphere(.) %>%
mutate(
K = Keff(K, hground, b),
Cd0 = Cd0clean + Cd0lg + Cd0flaps + Cdiflaps,
Cd0 = Cd0 + as.numeric(Ne == 1) * Cd0propfea + as.numeric(Ne == 0) * 2 * Cd0propunfea,
Cl = Cl0 + Clflaps,
Cd = Cd0 + KK * Cl^2
)
#--- Calculate the other LD parameters and find V1
LD <- LD %>%
mutate(
K = Keff(K, hground, b),
Cd = Cd0 + K * Cl^2
)
#--- Set up the initial parameters to solve for
LD <- inp
LD$segment <- "Landing"
LD$type <- "Landing"
LD$Ne <-0
LD$mu <- c(
as.double(groundmu["Dry Concrete", "brakeson"])
)
#---- Determine aerodynamic parameters
LD <- mutate(LD, h = 0) %>%
StandardAtomsphere(.) %>%
mutate(
K = Keff(K, hground, b),
Cd0 = Cd0clean + Cd0lg + Cd0flaps + Cdiflaps,
Cd0 = Cd0 + as.numeric(Ne == 1) * Cd0propfea + as.numeric(Ne == 0) * 2 * Cd0propunfea,
Cl = Cl0 + Clflaps,
Cd = Cd0 + K * Cl^2
)
50/GroundAcceleration(LD, 50, distancecalc = TRUE)
integrate(function(V) V/GroundAcceleration(LD, V, distancecalc = TRUE),
lower = 50, upper = 0)[[1]]
integrate(function(V) V/GroundAcceleration(LD, V, distancecalc = TRUE),
lower = 1.15*inp$VsLD, upper = 0)[[1]]
AccelerateLiftOff
#--- Output the results
LDoutput <- data.frame(
Vapp = AirDistLD$Vapp,
VTD = 1.15*inp$VsLD,
LD = VTD * 3 +
(integrate(function(V) V/GroundAcceleration(LD, V, distancecalc = TRUE),
lower = 1.15*inp$VsLD, upper = 0)[[1]]) * 1.67
) %>%
mutate(
LDgr = LD - AirDistanceLD$Sair[1] * 1.67
)
#--- Output the results
LDoutput <- data.frame(
Vapp = AirDistLD$Vapp,
VTD = 1.15*inp$VsLD
) %>%
mutate(
LD = VTD * 3 +
(integrate(function(V) V/GroundAcceleration(LD, V, distancecalc = TRUE),
lower = 1.15*inp$VsLD, upper = 0)[[1]]) * 1.67,
LDgr = LD - AirDistanceLD$Sair[1] * 1.67
)
#--- Determine the distance required for landing
AirDistLD <- inp
AirDistLD$type <- "All Engines"
AirDistLD$Ne <- 2
AirDistLD <- AirDistLD %>%
mutate(h = Hobsland) %>%
StandardAtomsphere(.) %>%
mutate(
Clapp = Clclean + Clhls,
Cd0 = Cd0clean + Cd0lg + Cd0flaps + Cdiflaps,
Vapp = 1.3* VsLD,
qinf = 1/2 * rho * Vapp^2,
etaprop = etaprop(Vapp),
PA = PA(Pshafteng, Ne, Vapp) * 0.05,
gammadeg = max(-3, ClimbRatesFunction(PA, Cd0, rho, Vapp, S, K, W)[[1]]),
gamma = gammadeg * pi/180,
L = W * cos(gamma),
Cl = L / (qinf * S),
Cd = Cd0 + K * Cl^2,
D = qinf * S * Cd,
TR = D - W * sin(gamma),
PR = TR * Vapp / etaprop,
R = Vapp^2 / (0.2 * g),
SF = R * sin(gamma),
hF = R * (1 - cos(gamma)),
SA = (Hobsland - hF) / tan(gamma),
Sair = ifelse(SA >0, SA + SF, sqrt(R^2 - (R-Hobsland)^2)))
#--- Output the results
LDoutput <- data.frame(
Vapp = AirDistLD$Vapp,
VTD = 1.15*inp$VsLD
) %>%
mutate(
LD = VTD * 3 +
(integrate(function(V) V/GroundAcceleration(LD, V, distancecalc = TRUE),
lower = 1.15*inp$VsLD, upper = 0)[[1]]) * 1.67,
LDgr = LD - AirDistLD$Sair[1] * 1.67
)
LDoutput
LDoutput <- data.frame(
Vapp = AirDistLD$Vapp,
VTD = 1.15*inp$VsLD
) %>%
mutate(
LD = VTD * 3 +
(integrate(function(V) V/GroundAcceleration(LD, V, distancecalc = TRUE),
lower = 1.15*inp$VsLD, upper = 0)[[1]]) * 1.67,
LDgr = LD/1.67 - AirDistLD$Sair[1]
)
LDoutput
integrate(function(V) V/GroundAcceleration(LD, V, distancecalc = TRUE),
lower = 1.15*inp$VsLD, upper = 0)[[1]]
#---- Determine aerodynamic parameters
LD <- mutate(LD, h = 0) %>%
StandardAtomsphere(.) %>%
mutate(
K = Keff(K, hground, b),
Cd0 = Cd0clean + Cd0lg + Cd0flaps + Cdiflaps,
Cd0 = Cd0 + as.numeric(Ne == 1) * Cd0propfea + as.numeric(Ne == 0) * 2 * Cd0propunfea,
Cl = Cl0 + Clflaps,
Cd = Cd0 + K * Cl^2
)
#--- Output the results
LDoutput <- data.frame(
Vapp = AirDistLD$Vapp,
VTD = 1.15*inp$VsLD
) %>%
mutate(
LD = (VTD * 3 +
integrate(function(V) V/GroundAcceleration(LD, V, distancecalc = TRUE),
lower = 1.15*inp$VsLD, upper = 0)[[1]]) * 1.67,
LDgr = LD/1.67 - AirDistLD$Sair[1]
)
#--- Output the results
LDoutput <- data.frame(
Vapp = AirDistLD$Vapp,
VTD = 1.15*inp$VsLD
) %>%
mutate(
LD = (VTD * 3 +
integrate(function(V) V/GroundAcceleration(LD, V, distancecalc = TRUE),
lower = 1.15*inp$VsLD, upper = 0)[[1]]) * 1.67,
LDgr = LD/1.67 - AirDistLD$Sair[1]
)
LDoutput
#--- Determine the distance required for landing
AirDistLD <- inp
AirDistLD$type <- "All Engines"
AirDistLD$Ne <- 2
AirDistLD <- AirDistLD %>%
mutate(h = Hobsland) %>%
StandardAtomsphere(.) %>%
mutate(
Clapp = Clclean + Clhls,
Cd0 = Cd0clean + Cd0lg + Cd0flaps + Cdiflaps,
Vapp = 1.3* VsLD,
qinf = 1/2 * rho * Vapp^2,
etaprop = etaprop(Vapp),
PA = PA(Pshafteng, Ne, Vapp) * 0.05,
gammadeg = max(-3, ClimbRatesFunction(PA, Cd0, rho, Vapp, S, K, W)[[1]]),
gamma = gammadeg * pi/180,
L = W * cos(gamma),
Cl = L / (qinf * S),
Cd = Cd0 + K * Cl^2,
D = qinf * S * Cd,
TR = D - W * sin(gamma),
PR = TR * Vapp / etaprop,
R = Vapp^2 / (0.2 * g),
SF = R * sin(gamma),
hF = R * (1 - cos(gamma)),
SA = (Hobsland - hF) / tan(gamma),
Sair = ifelse(SA >0, SA + SF, sqrt(R^2 - (R-Hobsland)^2)))
#--- Set up the initial parameters to solve for
LD <- inp
LD$segment <- "Landing"
LD$type <- "Landing"
LD$Ne <-0
LD$mu <- c(
as.double(groundmu["Dry Concrete", "brakeson"])
)
#---- Determine aerodynamic parameters
LD <- mutate(LD, h = 0) %>%
StandardAtomsphere(.) %>%
mutate(
K = Keff(K, hground, b),
Cd0 = Cd0clean + Cd0lg + Cd0flaps + Cdiflaps,
Cd0 = Cd0 + as.numeric(Ne == 1) * Cd0propfea + as.numeric(Ne == 0) * 2 * Cd0propunfea,
Cl = Cl0 + Clflaps,
Cd = Cd0 + K * Cl^2
)
#--- Output the results
LDoutput <- data.frame(
Vapp = AirDistLD$Vapp,
VTD = 1.15*inp$VsLD
) %>%
mutate(
LD = (VTD * 3 +
integrate(function(V) V/GroundAcceleration(LD, V, distancecalc = TRUE),
lower = 1.15*inp$VsLD, upper = 0)[[1]]) * 1.67,
LDgr = LD/1.67 - AirDistLD$Sair[1]
)
LDoutput
integrate(function(V) V/GroundAcceleration(LD, V, distancecalc = TRUE),
lower = 1.15*inp$VsLD, upper = 0)[[1]]
#--- Output the results
LDoutput <- data.frame(
Vapp = AirDistLD$Vapp,
VTD = 1.15*inp$VsLD
) %>%
mutate(
LD = (VTD * 3 +
integrate(function(V) V/GroundAcceleration(LD, V, distancecalc = TRUE),
lower = 1.15*inp$VsLD, upper = 0)[[1]] +
AirDistLD$Sair[1]) * 1.67,
LDgr = LD/1.67 - AirDistLD$Sair[1]
)
LDoutput
#--- Output the results
TOoutput <- data.frame(
V1 = V1,
V2 = V2,
BFL = BFL,
NTO = AccelerateLiftOff(TO, AirDistanceTO, V2)
) %>%
mutate(
NTOgr = NTO/1.15 - AirDistanceTO$Sair[1],
NTOair = AirDistanceTO$Sair[1],
TakeOffLength = max(BFL*as.numeric(V1 <= V2), NTO)
)
TOoutput
LDoutput
LDoutput <- data.frame(
Vapp = AirDistLD$Vapp,
VTD = 1.15*inp$VsLD
) %>%
mutate(
LD = (VTD * 3 +
integrate(function(V) V/GroundAcceleration(LD, V, distancecalc = TRUE),
lower = 1.15*inp$VsLD, upper = 0)[[1]] +
AirDistLD$Sair[1]) * 1.67,
LDgr = LD/1.67 - AirDistLD$Sair[1],
LDair = AirDistLD$Sair[1]
)
LDoutput
